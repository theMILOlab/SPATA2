
#' @import SingleCellExperiment
#'
NULL



#' Make sure that barcodes are spata-like
#'
#' @param input A matrix with columns = barcodes, or a data.frame with a barcode-variable
#' @param sample_name Character value.

hlpr_add_barcode_suffix <- function(input, sample_name){

  pattern <- stringr::str_c("_", sample_name, "$", sep = "")

  if(base::is.data.frame(input)){

    input <-
      dplyr::mutate(.data = input,
                    barcodes = dplyr::case_when(
                      stringr::str_detect(barcodes, pattern = pattern) ~ barcodes,
                      !stringr::str_detect(barcodes, pattern = pattern) ~ stringr::str_c(barcodes, {{sample_name}}, sep = "_")
                    ))


  } else {

    barcodes <- base::colnames(input)

    barcodes <-
      dplyr::case_when(
        stringr::str_detect(barcodes, pattern = pattern) ~ barcodes,
        !stringr::str_detect(barcodes, pattern = pattern) ~ stringr::str_c(barcodes, {{sample_name}}, sep = "_")
      )

    base::colnames(input) <- barcodes

  }

  base::return(input)

}

#' @title Adds old coordinates
#'
#' @description Adds old coordinates of subsetted object to
#' plot_df in \code{plotSurface()}.
#'
#' @inherit check_object params
#' @param plot_df The plot_df.
#' @param complete Logical.
#'
#' @return
#' @export

hlpr_add_old_coords <- function(object, plot_df, complete){

  # currently deprecated!
  if(FALSE){

    old_coords_df <- object@information$old_coordinates

    cnames <- base::colnames(plot_df)
    variable <- cnames[!cnames %in% coords_df_vars]

    res_df <-
      dplyr::add_row(.data = plot_df,
                     barcodes = old_coords_df$barcodes,
                     sample = old_coords_df$sample,
                     x = old_coords_df$x,
                     y = old_coords_df$y)

    variable_vec <- res_df[[variable]]

    if(base::is.factor(variable_vec)){

      variable_vec <- base::factor(x = variable_vec,
                                   levels = c(base::levels(variable_vec), "subs.by.segment")
                                   )

      res_df[[variable]][base::is.na(res_df[[variable]])] <- "subs.by.segment"

    }

  } else {

    res_df <- plot_df

  }


  base::return(res_df)
}


#' @title Adjusts the size of discrete legend points
#'
#' @inherit check_pt params
#' @param variable The variable mapped to the color/fill aesthetic.
#' @param aes The aesthetic used.

hlpr_adjust_legend_size <- function(variable, aes, pt_size){

  if(!base::is.numeric(variable)){

    if(aes == "color"){

      ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = pt_size * 2.5)))

    } else if(aes == "fill"){

      ggplot2::guides(fill = ggplot2::guide_legend(override.aes = list(size = pt_size * 2.5)))

    }

  } else {

    list()

  }

}


#' Assign arguments to calling function
#'
#' @description Mediates between the input of the calling function and
#' the default instructions within the spata object. Every 'default'-argument
#' of the calling function that is NULL is replaced by what is defined as
#' the default.
#'
#' @inherit check_object params

hlpr_assign_arguments <- function(object){

  check_object(object)

  default_instructions <- getDefaultInstructions(object)

  ce <- rlang::caller_env()

  cfn <- rlang::caller_fn()

  cargs <- rlang::fn_fmls_names(fn = cfn)

  default_args <- cargs[cargs %in% methods::slotNames(default_instructions)]

  for(arg in default_args){

    arg_value <-
      base::parse(text = arg) %>%
      base::eval(envir = ce)

    if(base::is.null(arg_value)){

      arg_value <- methods::slot(default_instructions, name = arg)

      base::assign(
        x = arg,
        value = arg_value,
        envir = ce
      )
    }

  }

  base::invisible(TRUE)

}


#' @title Calculates breaks for heatmap according to input matrix
#'

hlpr_breaks <- function(mtr, length_out){

  quantiles <-
    base::as.numeric(mtr) %>%
    stats::quantile()

  breaks <- base::seq(quantiles[2], quantiles[4], length.out = length_out)

  base::return(breaks)

}


#' @title Compare samples within an object
#'
#' @description Checks whether the sample column in \code{df}
#' complies with the sample names of the provided object.
#'
#' @param object A valid spata-object.
#' @param df A data.frame
#' @param messages The message vector that is generated by the function in which
#' \code{hlpr_compare_samples()} is called in.
#'
#' @return Updated message vector.
#'
#' @details This function is to be used within the \code{SPATA::validateSpataObject()}-
#' functions. It expands the message-vector that is being generated by the calling
#' function and returns it.

hlpr_compare_samples <- function(object, df, messages){

  df_samples <- stringr::str_c(base::unique(df$sample), collapse = ", ") %>% base::sort()
  o_samples <- stringr::str_c(samples(object), collapse = ", ") %>% base::sort()

  if(!base::identical(df_samples, o_samples)){

    feedback <-
      stringr::str_c("Inavlid samples in column 'sample'.:",
                     "\n In coordinates: ", df_samples,
                     "\n In object:      ", o_samples,
                     sep = "")

    messages <-
      base::append(x = messages,
                   values = feedback)

  }

  return(messages)

}


#' @title Compiles a trajectory data.frame
#'
#' @param segment_trajectory_df A data.frame specifying each segment of the whole
#' trajectory with variables \code{x, y, xend, yend}.
#' @param trajectory_width Numeric value that determines the width of the
#' trajectory.
#' @inherit check_sample params
#'
#' @return A data.frame containing the variables \emph{barcodes, sample, x, y}
#' as well as
#' \itemize{
#'  \item{\emph{projection_length}: indicating the position of every barcode-spot
#'  with respect to the direction of the trajectory-part. The higher the barcode-spots
#'  value is the farther away it is from the starting point of the trajectory-part
#'  it belongs to. }
#'  \item{\emph{trajectory_part}: indicating the part of the trajectory the barcode-spot
#'   belongs to.}
#'   }
#'
#' @export

hlpr_compile_trajectory <- function(segment_trajectory_df,
                                    trajectory_width,
                                    object,
                                    sample){

  check_object(object)

  all_trajectories_list <- list()

  for(i in 1:base::nrow(segment_trajectory_df)){

    # One dimensional part ----------------------------------------------------

    trajectory_vector_df <- segment_trajectory_df[i,1:4]

    start_point <- as.numeric(trajectory_vector_df[1:2])
    end_point <- as.numeric(trajectory_vector_df[3:4])

    trajectory_vec <- end_point - start_point

    # factor with which to compute the width vector
    trajectory_magnitude <- base::sqrt((trajectory_vec[1])^2 + (trajectory_vec[2])^2)
    trajectory_factor <- trajectory_width / trajectory_magnitude

    # orthogonal trajectory vector
    orth_trajectory_vec <- (c(-trajectory_vec[2], trajectory_vec[1]) * trajectory_factor)


    # Two dimensional part ----------------------------------------------------

    # determine trajectory frame points 'tfps' making up the square that embraces
    # the points
    tfp1.1 <- start_point + orth_trajectory_vec
    tfp1.2 <- start_point - orth_trajectory_vec
    tfp2.1 <- end_point - orth_trajectory_vec
    tfp2.2 <- end_point + orth_trajectory_vec

    trajectory_frame <-
      data.frame(
        x = c(tfp1.1[1], tfp1.2[1], tfp2.1[1], tfp2.2[1]),
        y = c(tfp1.1[2], tfp1.2[2], tfp2.1[2], tfp2.2[2])
      )

    # calculate every point of interests projection on the trajectory vector using 'vector projection'  on a local
    # coordinate system 'lcs' to sort the points according to the trajectories direction

    sample_coords <-
      getCoordsDf(object = object, of_sample = sample)

    lcs <- data.frame(
      x = c(tfp1.1[1], tfp1.1[1]),
      y = c(tfp1.1[2], tfp1.1[2]),
      xend = c(tfp2.2[1], tfp1.2[1]),
      yend = c(tfp2.2[2], tfp1.2[2]),
      id = c("local length axis", "local width axis")
    )

    positions <- sp::point.in.polygon(point.x = sample_coords$x,
                                      point.y = sample_coords$y,
                                      pol.x = trajectory_frame$x,
                                      pol.y = trajectory_frame$y)


    # Data wrangling part -----------------------------------------------------

    # points of interest data.frame
    points_of_interest <-
      sample_coords %>%
      dplyr::mutate(position = positions) %>%
      dplyr::filter(position != 0) %>% # filter only those that fall in the trajectory frame
      dplyr::select(-position) %>%
      dplyr::group_by(barcodes) %>%
      dplyr::mutate(projection_length = hlpr_vector_projection(lcs = lcs, x, y),
                    trajectory_part = stringr::str_c("Part", i, sep = " ")) %>%
      dplyr::arrange(projection_length) %>%  # arrange barcodes according to their projection value
      dplyr::ungroup()

    all_trajectories_list[[i]] <- points_of_interest

  }

  compiled_trajectory_df <- base::do.call(base::rbind, all_trajectories_list)

  return(compiled_trajectory_df)

}


#' @title No documentation needed
hlpr_display_title <- function(display_title, title){

  if(base::isTRUE(display_title)){

    add_on <- ggplot2::labs(title = title)

    base::return(add_on)

  } else {

    base::return(NULL)

  }

}

#' @rdname hlpr_display_title
hlpr_display_subtitle <- function(display_subtitle, subtitle){

  if(base::isTRUE(display_subtitle)){

    add_on <- ggplot2::labs(subtitle = subtitle)

    base::return(add_on)

  } else {

    base::return(NULL)

  }

}


#' @title Convert distance matrix to distance data.frame
#'
#' @description Reshapes a distance matrix with a wrapper around \code{reshape2::melt()}.
#'
#' @param dist_mtr A distance matrix gene expression - gene expression distances

hlpr_dist_mtr_to_df <- function(dist_mtr, varnames = c("gene1", "gene2")){

  dist_mtr <- base::as.matrix(dist_mtr)

  dist_mtr[base::upper.tri(x = dist_mtr, diag = TRUE)] <- NA

  reshape2::melt(data = dist_mtr,
                 na.rm = TRUE,
                 varnames = varnames,
                 value.name = "distance") %>%
    dplyr::mutate_if(.predicat = base::is.factor, .funs = base::as.character)

}

#' Removes the class part of a gene set string
#'
#' @param string Gene sets as a character vector
#'
#' @return Gene set name
#'

hlpr_gene_set_name <- function(string){

  stringr::str_remove(string = string, pattern = "^.+?_")

}


#' Easy switch between geom line and and geom smooth
#'
#' @description To be used in plotTrajectoryFit()/-Customized()

hlpr_geom_trajectory_fit <- function(smooth, smooth_span, plot_df){

  argument_list <- list(size = 1, alpha = 0.75)

  customized_df <- dplyr::filter(.data = plot_df, origin %in% c("Customized", "Fitted curve"))
  expression_df <- dplyr::filter(.data = plot_df, origin %in% c("Residuals", "Expression"))

  # construct add on
  if(base::isTRUE(smooth)){

    argument_list <-
      base::append(
        x = argument_list,
        values = list(span = smooth_span, formula = as.formula(y ~ x),
                      se = FALSE, method = "loess")
      )

    fn_to_call <-
      base::parse(text = "ggplot2::geom_smooth") %>%
      base::eval()

    customized_add_on <-
      rlang::invoke(
        .fn = fn_to_call,
        .args = base::append(
          x = list(data = customized_df, linetype = "solid"),
          values = argument_list)
      )

    expression_add_on <-
      rlang::invoke(
        .fn = fn_to_call,
        .args = base::append(
          x = list(data = expression_df, mapping = ggplot2::aes(linetype = origin)),
          values = argument_list)
      )

  } else {

    fn_to_call <-
      base::parse(text = "ggplot2::geom_line") %>%
      base::eval()

    customized_add_on <-
      rlang::invoke(
        .f = fn_to_call,
        .args = base::append(
          x = list(data = customized_df, linetype = "solid"),
          values = argument_list)
      )

    expression_add_on <-
      rlang::invoke(
        .f = fn_to_call,
        .args = base::append(
          x = list(data = expression_df, mapping = ggplot2::aes(linetype = origin)),
          values = argument_list)
      )

  }

  base::return(list(customized_add_on, expression_add_on))

}


#' @title Provides the image as ggplot background
#'
#' @inherit check_sample params
#' @param image Image input.
#' @param display_image Logical value.
#'
#' @return Either null or a ggplot2::geom_annotation_raster

hlpr_image_add_on <- function(object, display_image, of_sample){

  # set up background
  if(base::isTRUE(display_image)){

    sample_image <- getImage(object, of_sample)

    if("Image" %in% base::class(sample_image)){

      image_raster <-
        grDevices::as.raster(x = sample_image)

      img_info <-
        image_raster %>%
        magick::image_read() %>%
        magick::image_info()

      st_image <-
        image_raster %>%
        magick::image_read() %>%
        magick::image_flip()

      image_add_on <-
        ggplot2::annotation_raster(raster = st_image,
                                   xmin = 0, ymin = 0,
                                   xmax = img_info$width,
                                   ymax = img_info$height)

    } else {

      base::warning(glue::glue("Content of slot 'image' for sample '{of_sample}' must be of class 'Image' not of class '{base::class(sample_image)}'."))

      image_add_on <- list()

    }

  } else {

    image_add_on <- list()

  }

  base::return(image_add_on)

}

#' @rdname hlpr_image_add_on
hlpr_image_add_on2 <- function(image){

  if(!base::is.null(image)){

    if(!"Image" %in% base::class(image)){

      base::warning("Argument 'image' is neither NULL nor an object of class 'Image'. ")
      image_add_on <- NULL

    } else {

      image_raster <- grDevices::as.raster(image)

      image_info <-
        magick::image_read(image_raster) %>%
        magick::image_info()

      image_flipped <-
        magick::image_read(image_raster) %>%
        magick::image_flip()

      image_add_on <-
        ggplot2::annotation_raster(raster = image_flipped,
                                   xmin = 0, ymin = 0,
                                   xmax = image_info$width,
                                   ymax = image_info$height)

    }

  }

}



#' @title Return customized ggplot:labs()
#'
#' @description Helper function
#'
#' @param input The color_to argument
#' @param input_str Title-prefix. Should be one of \emph{'Genes:', 'Gene set:'} or \code{'Feature:'}.
#' @param color_str Legend title
#' @param display_title Logical. If set to FALSE only the legend-title will be specified.
#'
#' @return A customized \code{ggplot2::labs()}-function.

hlpr_labs_add_on <- function(input,
                             input_str,
                             color_str,
                             display_title){

  if(base::isTRUE(display_title)){

    if(base::length(input) > 5){

      input <- c(input[1:5], stringr::str_c("... +", (base::length(input)-5), sep = " "))

    }

    input_clpsd <- stringr::str_c(input, collapse = ", ")

    plot_title <- stringr::str_c(input_str, input_clpsd, sep = " ")

    base::return(ggplot2::labs(title = plot_title, color = color_str))

  } else {

    base::return(ggplot2::labs(color = color_str))

  }

}



#' @title Normalize gene or gene set values
#'
#' @description Helper function to use within \code{purrr::imap()}
#'
#' @param variable The variable to normalize (if matches requirements).
#' @param var_name The name of the variable to smooth.
#' @param aspect Gene or Gene set
#' @param subset A character vector of variable names that are to be normalized
#' @param pb An R6 progress bar object.
#'
#' @return A normalized variable (data.frame within \code{purrr::imap()})

hlpr_normalize_imap <- function(variable,
                                var_name,
                                aspect,
                                subset){

  if(!base::is.numeric(variable) | !var_name %in% subset){

      base::return(variable)

  } else if(base::all(variable == 0)){

      if(var_name == "mean_genes"){

        var_name <- "average"

      }

      base::warning(stringr::str_c(aspect, var_name, "contains only 0s. Returning NULL.", sep = " "))
      base::return(NULL)

  } else if(base::length(base::unique(variable)) == 1){

      if(var_name == "mean_genes"){

        var_name <- "average"

      }

      base::warning(stringr::str_c(aspect, var_name, "is uniformly expressed. Returning NULL.", sep = " "))
      base::return(NULL)

  } else {

      # normalize variable
      res <-
        (variable - base::min(variable)) /
        (base::max(variable) - base::min(variable))

      if(!base::any(base::is.na(res))){

      base::return(res)

      } else {

        base::warning(stringr::str_c(aspect, var_name, "normalization resulted in NaNs. Returning NULL.", sep = " "))
        base::return(NULL)

      }

  }

}



#' @inherit hlpr_normalize_imap params title
#'
#' @return A normalized variable
#' @export

hlpr_normalize_vctr <- function(variable){

  res <-
    (variable - base::min(variable)) /
    (base::max(variable) - base::min(variable))

  if(base::any(base::is.na(res))){

    base::return(variable)

  } else {

    base::return(res)

  }


}


#' @title Number of distinct values equal to 1?
#'
#' @description Helper function to use within purrr::map_lgl. Returns
#' TRUE if the gene row of the provided rna assay is uniformly expressed.
#'
#' @param x Input variable.
#' @param rna_assay Expression matrix
#' @param pb Progress bar object
#'
#' @return
#' @export
#'

hlpr_one_distinct <- function(x, rna_assay, pb = NULL, verbose = TRUE){

  if(!base::is.null(pb)){pb$tick()}

  res <- dplyr::n_distinct(rna_assay[x,]) == 1

  base::return(res)

}


#' @title Process spatial correlation results
#'
#' @description Helper function to be used in \code{clusterSpatialCorrelationResults()}.
#' Takes a cutree data.frame and a distance data.frame and returns a named list:
#'
#' \itemize{
#'  \item{\emph{assessment_df}: A data.frame that attempts to evaluate all cluster's
#'   quality by providing the average distance between it's genes.}
#'   \item{\emph{distances_list}: A named list of data.frames. Each data.frame contains the
#'   gene-gene distances between all genes the cluster it corresponds to contains.}
#'   \item{\emph{gene_names_list}: A named list of character vectors. Each vector contains the
#'   unique gene names of the cluster it corresponds to.}
#'   \item{\emph{k}: k-value}
#'   \item{\emph{h}: h-value}
#'   }
#'
#' @param cutree_df Data.frame of two variables: gene and cluster-belonging.
#' @param dist_df Data.frame of three variables: gene1, gene2, distance
#'

hlpr_process_spatial_correlation_cluster <- function(cutree_df, dist_df, input){

  cluster_list_genes <-
    purrr::map(.x = base::unique(cutree_df$cluster),
               cutree_df = cutree_df,
               .f = function(cluster, cutree_df){

                 dplyr::filter(.data = cutree_df, cluster == {{cluster}}) %>%
                   dplyr::pull(var = "genes")

               }) %>%
    purrr::set_names(nm = base::unique(cutree_df$cluster))


  cluster_list_distances <-
    purrr::map(.x = cluster_list_genes,
               dist_df = dist_df,
               .f = function(cluster_genes, dist_df){

                 arranged_dist_df <-
                   dplyr::filter(dist_df,
                                 gene1 %in% {{cluster_genes}} &
                                   gene2 %in% {{cluster_genes}}) %>%
                   dplyr::filter(gene1 != gene2) %>%
                   dplyr::arrange(distance) %>%
                   tibble::as_tibble()

               }) %>%
    purrr::keep(.p = ~ base::nrow(.x) >= 2)

  cluster_df_assessment <-
    purrr::map_df(.x = cluster_list_distances,
                  .f = function(dist_df){

                    dplyr::summarise(.data = dist_df,
                                     mean_distance = base::mean(distance),
                                     median_distance = stats::median(distance),
                                     n_genes = dplyr::n_distinct(gene1))


                  }) %>%
    dplyr::mutate(cluster = base::names(cluster_list_distances)) %>%
    dplyr::select(cluster, dplyr::everything()) %>%
    dplyr::arrange(mean_distance)

  cluster_list_genes <-
    purrr::map(.x = cluster_list_distances,
               .f = function(dist_df){

                 dplyr::select(dist_df, gene1, gene2) %>%
                   base::as.matrix() %>%
                   base::t() %>%
                   base::as.character() %>%
                   base::unique()

               })

  cluster_list <-
    list("assessment_df" = cluster_df_assessment,
         "distances_list" = cluster_list_distances,
         "gene_names_list" = cluster_list_genes,
         "h" = input$h,
         "k" = input$k,
         "method" = input$method)

  base::return(cluster_list)

}


#' @title Save spata object inside functions
#'
#' @inherit argument_dummy params
#' @inherit check_object params
#' @param object_file The directory under which to store the object.
#' @param ref_step Character value.
#'

hlpr_save_spata_object <- function(object, object_file, ref_step, verbose){

  if(!base::is.null(object_file)){

    if(base::isTRUE(verbose)){glue::glue(base::message("Step {ref_step}: Saving spata-object."))}

    base::saveRDS(object, file = object_file)

    if(base::isTRUE(verbose)){

      base::message(glue::glue("The spata-object has been saved under '{object_file}'."))
      base::message("Done.")

    }

  } else {

    if(base::isTRUE(verbose)){
      base::message(glue::glue("Skipping step {ref_step} (saving) as 'output_path' was set to NULL."))
      base::message("Done.")
    }

  }


}




#' @title Color to + scatterplot helper
#'
#' @inherit joinWith params
#' @param color_to Named list.
#'
#' @return A named list. Slot \emph{data} contains a data.frame as input for \code{data} of \code{ggplot2::ggplot()} and
#' slot \emph{add_on} contains a list of ggplot-add-ons.
#'

hlpr_scatterplot <- function(object,
                             spata_df,
                             color_to,
                             method_gs = "mean",
                             display_title = FALSE,
                             pt_size = 2,
                             pt_alpha = 1,
                             pt_clrsp = "inferno",
                             pt_clrp = "milo",
                             pt_clr = "black",
                             smooth = FALSE,
                             smooth_span = 0.02,
                             normalize = TRUE,
                             verbose = TRUE,
                             complete = FALSE,
                             ...){

  # if feature
  if("features" %in% base::names(color_to)){

    feature <- color_to$features

    spata_df <- joinWithFeatures(object = object,
                                 spata_df = spata_df,
                                 features = feature,
                                 smooth = smooth,
                                 smooth_span = smooth_span,
                                 verbose = verbose)

    if(is_subsetted_by_segment(object)){

      spata_df <-
        hlpr_add_old_coords(
          object = object,
          plot_df = spata_df,
          complete = complete
        )

    }

    # assemble ggplot add on
    ggplot_add_on <- list(
      ggplot2::geom_point(data = spata_df, size = pt_size, alpha = pt_alpha,
                          mapping = ggplot2::aes(color = .data[[feature]])),
      confuns::scale_color_add_on(aes = "color", clrsp = pt_clrsp, clrp = pt_clrp,
                                  variable = spata_df[[feature]], ...),
      hlpr_adjust_legend_size(aes = "color", pt_size = pt_size, variable = spata_df[[feature]]),
      ggplot2::labs(color = feature)
    )

    # if gene set
  } else if("gene_sets" %in% base::names(color_to)){

    gene_set <- color_to$gene_sets

    spata_df <- joinWithGeneSets(object = object,
                                 spata_df = spata_df,
                                 gene_sets = gene_set,
                                 method_gs = method_gs,
                                 smooth = smooth,
                                 smooth_span = smooth_span,
                                 normalize = normalize,
                                 verbose = verbose)

    # currently not in use
    if(is_subsetted_by_segment(object)){

      spata_df <-
        hlpr_add_old_coords(
          object = object,
          plot_df = spata_df,
          complete = complete
        )

    }


    # display informative title
    if(base::isTRUE(display_title)){

      title <-
        stringr::str_c("Gene set: ", gene_set, " (", method_gs, ")", sep = "")

    } else {

      title <- NULL

    }


    # assemble ggplot add-on
    ggplot_add_on <- list(
      ggplot2::geom_point(data = spata_df, size = pt_size, alpha = pt_alpha,
                          mapping = ggplot2::aes(color = .data[[gene_set]])),
      confuns::scale_color_add_on(aes = "color", clrsp = pt_clrsp, ...),
      ggplot2::labs(color = NULL, title = title, caption = gene_set)
    )

    # if genes
  } else if("genes" %in% base::names(color_to)){

    genes <- color_to$genes

    spata_df <- joinWithGenes(object = object,
                              spata_df = spata_df,
                              genes = color_to$genes,
                              average_genes = TRUE,
                              smooth = smooth,
                              smooth_span = smooth_span,
                              normalize = normalize,
                              verbose = verbose)

    # currently not in use
    if(is_subsetted_by_segment(object)){

      spata_df <-
        hlpr_add_old_coords(
          object = object,
          plot_df = spata_df,
          complete = complete
        )

    }


    if(base::isTRUE(display_title)){

      title <-
        glue::glue("Gene: {genes}",
                   genes = glue::glue_collapse(x = color_to$genes, sep = ", ", width = 7, last = " and "))

    } else {

      title <- NULL

    }


    # assemble ggplot add-on
    ggplot_add_on <- list(
      ggplot2::geom_point(data = spata_df, size = pt_size, alpha = pt_alpha,
                          mapping = ggplot2::aes(color = .data[["mean_genes"]])),
      confuns::scale_color_add_on(aes = "color", clrsp = pt_clrsp, ...),
      ggplot2::labs(color = base::ifelse(base:::length(genes) == 1, genes, "Mean\nExpr."), title = title)
    )

    # else if color_to has not been specified
  } else if("color" %in% base::names(color_to)){

    ggplot_add_on <-
      ggplot2::geom_point(data = spata_df, size = pt_size, alpha = pt_alpha, color = color_to$color)

  }

  base::return(
    list(data = spata_df,
         add_on = ggplot_add_on
    )
  )

}


#' @title Smooth variables spatially
#'
#' @description Helper function to be used within \code{purrr::imap()}
#'
#' @param variable The variable to smooth
#' @param var_name Name of the variable to smooth
#' @param coords_df Data.frame that contains x and y coordinates
#' @param smooth_span Span to smooth with
#' @param aspect Gene or Gene set
#' @param subset Vector of variable names to smooth
#' @param pb A progress-bar or NULL.
#'
#' @return Smoothed variable (data.frame within \code{purrr::imap()})
#' @export

hlpr_smooth <- function(variable,
                        var_name,
                        coords_df,
                        smooth_span,
                        aspect,
                        subset,
                        pb = NULL){

  if(!base::is.null(pb)){

    pb$tick()

  }

  data <-
    base::cbind(variable, coords_df[, c("x", "y")]) %>%
    magrittr::set_colnames(value = c("rv", "x", "y"))

  if(!var_name %in% subset){

    base::return(variable)

  } else if(!base::is.numeric(data$rv)){

    if(var_name == "mean_genes"){

      var_name <- "average"

    }

    msg <- stringr::str_c("Skip smoothing of ", aspect, " '", var_name, "' as it is of class '", base::class(dplyr::pull(data, rv)), "'.")

    confuns::give_feedback(msg = msg)

    base::return(variable)

  } else if(base::any(base::is.na(data$rv)) |
            base::any(base::is.nan(data$rv))|
            base::any(base::is.infinite(data$rv))){

    if(var_name == "mean_genes"){

      var_name <- "average"

    }

    base::warning(stringr::str_c("Skip smoothing of", aspect, var_name, "as it contains NaNs or infinites.", sep = " "))
    base::return(variable)

  } else {

    smooth_span <- smooth_span/10

    model <- stats::loess(formula = rv ~ x * y, data = data, span = smooth_span)

    base::return(stats::predict(object = model))

  }

}


#' @title Smooth variable spatially in mini-shiny-apps
#'
#' @description Helper function to use independently (or in a pipe)
#'
#' @inherit hlpr_smooth params
#'
#' @return Data.frame with the smoothed variable specified in \code{variable}.
#'
hlpr_smooth_shiny <- function(variable,
                              coords_df,
                              smooth_span){

  base::colnames(coords_df)[base::which(base::colnames(coords_df) == variable)] <- "response_variable"

  if(base::is.numeric(coords_df$response_variable)){

    model <- stats::loess(formula = response_variable ~ x * y, span = smooth_span, data = coords_df)

    smoothed_df_prel <-
      broom::augment(model) %>%
      dplyr::select(x, y, .fitted) %>%
      magrittr::set_colnames(value = c("x", "y", variable))

    selected_df <- dplyr::select(coords_df, -c("x", "y", "response_variable"))

    smoothed_df <-
      base::cbind(smoothed_df_prel, selected_df) %>%
      dplyr::select(barcodes, sample, x, y, dplyr::everything()) %>%
      as.data.frame()


    # if coords_df derived from trajectory analysis
    if("trajectory_order" %in% base::colnames(coords_df)){

      smoothed_df$trajectory_order <- coords_df$trajectory_order

    }

    if(base::nrow(smoothed_df) == base::nrow(coords_df)){

      base::return(smoothed_df)

    } else {

      shiny::showNotification(ui = "Smoothing failed. Return original values.",
                              type = "warning")

      base::return(coords_df)

    }


  } else {

    shiny::showNotification(ui = "Can not smooth features that aren't of class 'numeric'. Skip smoothing.",
                            type = "warning")

    base::colnames(coords_df)[base::which(base::colnames(coords_df) == "response_variable")] <- variable

    base::return(coords_df)

  }

}


#' Subset the across-variables
#'
#' @description Checks across and across_subset input and if at least one
#' of the across_subset values exists filters the data accordingly.
#'
#' @param data A data.frame that contains the variable specified in \code{across}.
#' @param across Character value. Denotes the discrete variable in the data.frame
#' across which something is to be analyzed or displayed.
#' @param across_subset Character vector. The groups of interest that the \code{across}-
#' variable contains.
#'
#' @return A filtered data.frame, informative messages or an error.
#' @export
#'

hlpr_subset_across <- function(data, across, across_subset){


  if(base::is.null(across_subset)){

    base::return(data)

  } else {

    data[[across]] <- confuns::unfactor(data[[across]])

    ref.against <-
      glue::glue("'{across}'-variable of the specified spata-object") %>%
      base::as.character()

    across_subset <-
      confuns::check_vector(
        input = across_subset,
        against = base::unique(data[[across]]),
        verbose = TRUE,
        ref.input = "'across_subset'",
        ref.against = ref.against) %>%
      base::as.character()

    data <- dplyr::filter(.data = data, !!rlang::sym(across) %in% {{across_subset}})

    base::return(data)

  }

}



#' @title Join and summarize compiled trajectory data.frames
#'
#' @description Joins a compiled trajectory data.frame with
#' the desired information and summarizes those.
#'
#' @inherit argument_dummy params
#' @inherit check_compiled_trajectory_df params
#' @inherit check_method params
#' @inherit check_object params
#' @inherit check_trajectory_binwidth params
#' @inherit check_variables params
#' @inherit normalize params
#'
#' @details Initially the compiled trajectory data.frame of the specified trajectory
#' is joined with the respective input of variables via \code{joinWithVariables()}.
#'
#' The argument \code{binwidth} refers to the amount of which the barcode-spots of the
#' given trajectory will be summarized with regards to the trajectory's direction:
#' The amount of \code{binwidth} and the previously specified 'trajectory width' in \code{createTrajectories()}
#' determine the length and width of the sub-rectangles in which the rectangle the
#' trajectory embraces are splitted and in which all barcode-spots are binned.
#' Via \code{dplyr::summarize()} the variable-means of every sub-rectangle are calculated.
#' These mean-values are then arranged according to the trajectory's direction.
#'
#' Eventually the data.frame is shifted via \code{tidyr::pivot_longer()} to a data.frame in which
#' every observation refers to the mean-value of one of the specified variable-elements (e.g. a specified
#' gene set) of the particular sub-rectangle. The returned data.frame contains the following variables:
#'
#' \itemize{
#'  \item{\emph{trajectory_part}: Character. Specifies the trajectory's sub-part of the observation. (Negligible if there is
#'  only one trajectory part.)}
#'  \item{\emph{trajectory_part_order}: Numeric. Indicates the order within the trajectory-part. (Negligible if there is
#'  only one trajectory part.)}
#'  \item{\emph{trajectory_order}: Numeric. Indicates the order within the whole trajectory.}
#'  \item{\emph{gene_sets, genes or features}: Character. The respective gene sets, gene or feature the value refers to.}
#'  \item{\emph{values}: Numeric. The actual summarized values.}}
#'
#' @export

hlpr_summarize_trajectory_df <- function(object,
                                         ctdf,
                                         binwidth = 5,
                                         variables,
                                         method_gs = "mean",
                                         verbose = TRUE,
                                         normalize = FALSE){


  # 1. Control --------------------------------------------------------------

  # lazy check
  check_object(object)
  check_compiled_trajectory_df(ctdf = ctdf)

  stopifnot(base::is.numeric(binwidth))
  stopifnot(base::is.character(variables))
  stopifnot(base::is.logical(verbose))

  # adjusting check

  variables <- check_variables(variables = variables,
                               all_features = getFeatureNames(object, of_class = c("numeric", "integer")),
                               all_gene_sets = getGeneSets(object),
                               all_genes = getGenes(object),
                               max_slots = 3,
                               max_length = Inf)

  if("features" %in% base::names(variables)){

    variables[["features"]] <- check_features(object = object,
                                     features = variables[["features"]],
                                     valid_classes = c("numeric", "integer"))

  }

  # -----

  # 2. Summarize and join compiled trajectory data.frame --------------------

  # join data.frame with variables
  joined_df <-
    dplyr::mutate(.data = ctdf,
                  order_binned = plyr::round_any(x = projection_length,
                                                 accuracy = binwidth,
                                                 f = base::floor)) %>%
    joinWithVariables(object = object,
                      spata_df = .,
                      variables = variables,
                      method_gs = method_gs,
                      average_genes = FALSE,
                      smooth = FALSE,
                      normalize = FALSE,
                      verbose = verbose)

  # keep only variables that were successfully joined
  variables <- base::unlist(variables, use.names = FALSE)
  variables <- variables[variables %in% base::colnames(joined_df)]

  # summarize data.frame
  confuns::give_feedback(
    msg = "Summarizing trajectory data.frame. (This might take a few moments.)",
    verbose = verbose
  )

  summarized_df <-
    dplyr::group_by(.data = joined_df, trajectory_part, order_binned) %>%
    dplyr::summarise(dplyr::across(.cols = dplyr::all_of(x = variables),
                                   .fns = ~ mean(., na.rm = TRUE)),
                     .groups = "drop_last") %>%
    dplyr::mutate(trajectory_part_order = dplyr::row_number()) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(trajectory_order = dplyr::row_number()) %>%
    dplyr::select(-order_binned) %>%
    tidyr::pivot_longer(cols = dplyr::all_of(x = variables),
                        names_to = "variables",
                        values_to = "values")

  if(base::isTRUE(normalize)){

    confuns::give_feedback(
      msg = "Normalizing values.",
      verbose = verbose
    )

    summarized_df <-
      dplyr::group_by(.data = summarized_df, variables) %>%
      dplyr::mutate(values = confuns::normalize(x = values)) %>%
      dplyr::ungroup()

  }

  confuns::give_feedback(msg = "Done.", verbose = verbose)

  # -----

  base::return(summarized_df)

}

#' @title Perform vector projection
#'
#' @description Helper function for trajectory-analysis to use within
#' \code{dplyr::mutate()}. Performs vector-projection with a spatial position
#' and a local coordinates system to arrange the barcodes that fall into a
#' trajectory square according to the trajectory direction.
#'
#' @param lcs A data.frame specifying the local coordinates system with variables
#' \code{x, y, xend, yend} and the observations \emph{local length axis} and
#' \emph{local width axis}.
#' @param x_coordinate x-coordinate
#' @param y_coordinate y-coordinate
#'
#' @return The projected length.
#'
#' @export

hlpr_vector_projection <- function(lcs, x_coordinate, y_coordinate){

  # vector from point of interest to origin of local coord system: 'vto'
  vto <- c((x_coordinate - lcs$x[1]), (y_coordinate - lcs$y[1]))

  # define local length axis (= relocated trajectory): 'lla'
  lla <- c((lcs$xend[1] - lcs$x[1]), (lcs$yend[1] - lcs$y[1]))

  # define lambda coefficient
  lambda <-
    ((vto[1] * lla[1]) + (vto[2] * lla[2])) / base::sqrt((lla[1])^2 + (lla[2])^2)^2

  # projecting vector on length axis
  pv <- lambda * (lla)

  # compute the length of the projected vector
  res <- base::sqrt((pv[1])^2 + (pv[2])^2)

  base::return(res)


}



#' @title Widen trajectory data.frame
#'
#' @param stdf A summarized trajectory data.frame - output
#' from \code{hlpr_summarize_trajectory_df()}.
#' @param variable Character value. The variable of \code{stdf}:
#' \emph{'gene_sets', 'genes'} or \emph{'features'}.
#'
#'
#' @return A widened data.frame in which each every observation is a
#' trajectory and every variable describes the value of the trajectory
#' at a specific position.
#'
#' @export
#'

hlpr_widen_trajectory_df <- function(stdf,
                                     variable){

  tidyr::pivot_wider(data = tdf,
                     id_cols = dplyr::all_of(c("trajectory_order", variable)),
                     names_from = dplyr::all_of(c("trajectory_part", "trajectory_order")),
                     values_from = "values")


}


#' @title Helper functions for trajectory ranking
#'
#' @description Functions to use within \code{purrr::map()} again in \code{dplyr::mutate()} in order to
#' create a nested ranked trajectory data.frame.
#'
#' \itemize{
#'  \item{\code{hlpr_add_models()}: Returns a data.frame of variables corresponding to
#'  mathematical curves.}
#'  \item{\code{hlpr_add_residuals(): Calculates the residuals of the variable \emph{values} with respect
#'  to each mathematical curve.}}
#'  \item{\code{hlpr_summarise_residuals(): Calculates the area under the curve for every residual in order to
#'  access the fit of the respective expression trend to the fitted curve.}}}
#'
#' @param df A data.frame.
#' @param customized_trends_df A data.frame of only numeric variables that represent the trends a trajectory
#' might adopt.
#'
#' @return If used within \code{purrr::map()} a list of data.frames.
#' @export
#'

hlpr_add_models <- function(df, custom_fit = NULL){

  dplyr::transmute(.data = df,
                   trajectory_order = trajectory_order,
                   p_one_peak = confuns::fit_curve(trajectory_order, "one_peak"),
                   p_one_peak_rev = confuns::fit_curve(trajectory_order, "one_peak", rev = TRUE),
                   p_two_peaks = confuns::fit_curve(trajectory_order, "two_peaks"),
                   p_two_peaks_rev = confuns::fit_curve(trajectory_order, "two_peaks", rev = TRUE),
                   p_gradient_desc = confuns::fit_curve(trajectory_order, "gradient"),
                   p_gradient_asc = confuns::fit_curve(trajectory_order, "gradient", rev = TRUE),
                   p_log_asc = confuns::fit_curve(trajectory_order, "log"),
                   p_log_desc = confuns::fit_curve(trajectory_order, "log", rev = TRUE),
                   p_lin_asc = confuns::fit_curve(trajectory_order, "linear"),
                   p_lin_desc = confuns::fit_curve(trajectory_order, "linear", rev = TRUE),
                   p_sin = confuns::fit_curve(trajectory_order, "sinus"),
                   p_sin_rev = confuns::fit_curve(trajectory_order, "sinus", rev = TRUE),
                   p_early_peak = confuns::fit_curve(trajectory_order, "early_peak"),
                   p_late_peak = confuns::fit_curve(trajectory_order, "late_peak"),
                   p_custom = custom_fit
  )

}

#' @rdname hlpr_add_models
#' @export
hlpr_add_residuals <- function(df, pb = NULL, custom_fit = NULL){

  if(!base::is.null(pb)){

    pb$tick()

  }

    dplyr::transmute(.data = df,
                     trajectory_order = trajectory_order,
                     p_one_peak =  (values - confuns::fit_curve(trajectory_order, "one_peak"))^2,
                     p_one_peak_rev = (values - confuns::fit_curve(trajectory_order, "one_peak", rev = TRUE))^2,
                     p_two_peaks = (values - confuns::fit_curve(trajectory_order, "two_peaks"))^2,
                     p_two_peaks_rev = (values - confuns::fit_curve(trajectory_order, "two_peaks", rev = TRUE))^2,
                     p_gradient_desc = (values - confuns::fit_curve(trajectory_order, "gradient"))^2,
                     p_gradient_asc = (values - confuns::fit_curve(trajectory_order, "gradient", rev = TRUE))^2,
                     p_log_asc = (values - confuns::fit_curve(trajectory_order, "log"))^2,
                     p_log_desc = (values - confuns::fit_curve(trajectory_order, "log", rev = TRUE))^2,
                     p_lin_asc = (values - confuns::fit_curve(trajectory_order, "linear"))^2,
                     p_lin_desc = (values - confuns::fit_curve(trajectory_order, "linear", rev = TRUE))^2,
                     p_sin = (values - confuns::fit_curve(trajectory_order, "sinus"))^2,
                     p_sin_rev = (values - confuns::fit_curve(trajectory_order, "sinus", rev = TRUE))^2,
                     p_early_peak = (values - confuns::fit_curve(trajectory_order, "early_peak"))^2,
                     p_late_peak = (values - confuns::fit_curve(trajectory_order, "late_peak"))^2)

}


#' @rdname hlpr_add_models
#' @export
hlpr_add_residuals_customized <- function(df, customized_trends_df, pb = NULL){

  if(!base::is.null(pb)){

    pb$tick()

  }

  dplyr::mutate(.data = customized_trends_df, original_values = df$values) %>%
    dplyr::mutate(dplyr::across(.fns = ~ (.x - original_values)^2)) %>%
    dplyr::select(-original_values) %>%
    dplyr::rename_with(.fn = ~ stringr::str_c("p", .x, sep = "_")) %>%
    dplyr::mutate(trajectory_order = dplyr::row_number())

}


#' @rdname hlpr_add_models
#' @export
hlpr_summarize_residuals <- function(df, pb = NULL){

  if(!base::is.null(pb)){

    pb$tick()

  }

  purrr::map_dfc(.x = dplyr::select(df, -trajectory_order),
                 .f = function(y){

                   pracma::trapz(x = df$trajectory_order, y = y)

                 })

}

#' @rdname hlpr_add_models
#' @export
hlpr_name_models <- function(names){

  stringr::str_replace_all(
    string = names,
    pattern = c(
      "gradient_desc" = "Gradient descending",
      "gradient_asc" = "Gradient ascending",
      "lin_desc" = "Linear descending",
      "lin_asc" = "Linear ascending",
      "log_desc" = "Logarithmic descending",
      "log_asc" = "Logarithmic ascending",
      "one_peak_rev" = "One peak (reversed)",
      "one_peak" = "One peak",
      "sin_rev" = "Sinus (reversed)",
      "sin" = "Sinus",
      "two_peaks_rev" = "Two peaks (reversed)",
      "two_peaks" = "Two peaks",
      "early_peak" = "Early peak",
      "late_peak" = "Late peak",
      "custom_fit" = "Custom fit"
    )
  )

}

#' @rdname hlpr_add_models
#' @export
hlpr_filter_trend <- function(atdf, limit, poi){

  check_atdf(atdf)
  confuns::is_value(x = limit, mode = "numeric", ref = "limit")

  res <-
    dplyr::filter(.data = atdf, pattern %in% poi & auc <= limit) %>%
    dplyr::pull(var = variables) %>% base::unique()

  if(base::length(res) == 0){

    base::stop(glue::glue("No trajectory-trends of pattern '{stringr::str_c(poi, collapse = ', ')}' found with auc lower than {limit}."))

  } else {

    base::return(res)

  }

}





